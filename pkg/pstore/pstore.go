// Package pstore provides operations for Linux pstore,
// mainly to read the pstore log on reboot.
// ref. https://www.freedesktop.org/software/systemd/man/latest/systemd-pstore.service.html
package pstore

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/leptonai/gpud/pkg/log"
)

// DefaultPstoreDir is the default directory for pstore logs.
// e.g., "/var/lib/systemd/pstore/7530486857247/dmesg.txt"
// The numeric subdirectory (e.g., "7530486857247") is a unique identifier
// generated by systemd-pstore, often based on the machine's DMI product UUID,
// to distinguish logs from different machines or boot instances.
const DefaultPstoreDir = "/var/lib/systemd/pstore"

const schemaVersion = "v0_7_0"

const (
	// pstoreHistoryTableColumnTimestamp represents the event timestamp in unix seconds.
	pstoreHistoryTableColumnTimestamp = "timestamp"

	// pstoreHistoryTableColumnEventName represents the event name.
	pstoreHistoryTableColumnEventName = "event_name"

	// pstoreHistoryTableColumnMessage represents the event message.
	pstoreHistoryTableColumnMessage = "message"

	// pstoreHistoryTableColumnRawMessage represents the raw event message.
	pstoreHistoryTableColumnRawMessage = "raw_message"
)

type History struct {
	// Timestamp represents the event timestamp in unix seconds.
	Timestamp  int64
	EventName  string
	Message    string
	RawMessage string
}

type Store interface {
	// Scan scans the pstore logs with the match function, and inserts
	// the matching events into the database.
	Scan(ctx context.Context, matchFunc func(line string) (eventName string, message string)) error

	// Get returns the history events since the given timestamp.
	Get(ctx context.Context, since time.Time) ([]History, error)
}

var _ Store = &pstoreReader{}

type pstoreReader struct {
	// e.g., "/var/lib/systemd/pstore"
	dir string

	dbRW *sql.DB
	dbRO *sql.DB

	historyTable string

	getTimeNow     func() time.Time
	lookBackPeriod time.Duration
}

func New(dir string, dbRW *sql.DB, dbRO *sql.DB, tableName string, lookBackPeriod time.Duration) (Store, error) {
	pr := &pstoreReader{
		dir:            dir,
		dbRW:           dbRW,
		dbRO:           dbRO,
		historyTable:   tableName + "_" + schemaVersion,
		lookBackPeriod: lookBackPeriod,
		getTimeNow: func() time.Time {
			return time.Now().UTC()
		},
	}

	if err := pr.init(); err != nil {
		return nil, err
	}

	// always purge old records
	// to prevent the database from growing too large
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	if err := purgeHistory(ctx, dbRW, pr.historyTable, pr.getTimeNow().Add(-lookBackPeriod)); err != nil {
		return nil, err
	}

	return pr, nil
}

func (pr *pstoreReader) Scan(ctx context.Context, matchFunc func(line string) (eventName string, message string)) error {
	// use the current time as the timestamp
	// to avoid complexity of timestamp parsing from pstore
	// as it's hard to get the accurate timestamp
	// around kernel crash
	now := pr.getTimeNow()
	nowUnix := now.Unix()
	findSince := now.Add(-pr.lookBackPeriod)

	// Recursively scan all files in the pstore directory with max depth of 3
	err := pr.scanDir(ctx, pr.dir, nowUnix, findSince, matchFunc, 0, 3)
	if err != nil {
		return err
	}

	return nil
}

// scanDir recursively scans a directory for pstore files with depth limit
func (pr *pstoreReader) scanDir(ctx context.Context, dir string, nowUnix int64, findSince time.Time, matchFunc func(line string) (eventName string, message string), currentDepth, maxDepth int) error {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		path := filepath.Join(dir, entry.Name())

		if entry.IsDir() {
			// Only recurse if we haven't reached max depth
			if currentDepth < maxDepth {
				if err := pr.scanDir(ctx, path, nowUnix, findSince, matchFunc, currentDepth+1, maxDepth); err != nil {
					return err
				}
			} else {
				log.Logger.Debugw("skipping directory due to max depth", "dir", path, "depth", currentDepth)
			}
			continue
		}

		// Process regular file
		log.Logger.Debugw("reading pstore file", "file", path)

		b, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		for line := range bytes.SplitSeq(b, []byte("\n")) {
			if len(line) == 0 {
				continue
			}

			raw := string(line)
			ev, msg := matchFunc(raw)
			if ev == "" {
				continue
			}

			h := &History{
				Timestamp:  nowUnix,
				EventName:  ev,
				Message:    msg,
				RawMessage: raw,
			}
			cnt, err := findHistoryByRawMessage(ctx, pr.dbRO, pr.historyTable, raw, findSince)
			if err != nil {
				return err
			}
			if cnt > 0 {
				// already exists
				continue
			}
			if err := insertHistory(ctx, pr.dbRW, pr.historyTable, h); err != nil {
				return err
			}
			log.Logger.Infow("inserted pstore history", "event_name", ev, "message", msg)
		}
	}

	return nil
}

func (pr *pstoreReader) Get(ctx context.Context, since time.Time) ([]History, error) {
	rows, err := pr.dbRO.QueryContext(ctx, fmt.Sprintf(`SELECT %s, %s, %s, %s FROM %s WHERE %s >= ?;`,
		pstoreHistoryTableColumnTimestamp, pstoreHistoryTableColumnEventName, pstoreHistoryTableColumnMessage, pstoreHistoryTableColumnRawMessage, pr.historyTable, pstoreHistoryTableColumnTimestamp,
	), since.Unix())
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	defer rows.Close()

	histories := make([]History, 0)
	for rows.Next() {
		var h History
		if err := rows.Scan(&h.Timestamp, &h.EventName, &h.Message, &h.RawMessage); err != nil {
			return nil, err
		}
		histories = append(histories, h)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return histories, nil
}

func (pr *pstoreReader) init() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := createHistoryTable(ctx, pr.dbRW, pr.historyTable); err != nil {
		return err
	}

	return nil
}

func createHistoryTable(ctx context.Context, dbRW *sql.DB, tableName string) error {
	tx, err := dbRW.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	// create table
	_, err = tx.ExecContext(ctx, fmt.Sprintf(`
CREATE TABLE IF NOT EXISTS %s (
	%s INTEGER NOT NULL,
	%s TEXT NOT NULL,
	%s TEXT NOT NULL,
	%s TEXT NOT NULL
);`, tableName,
		pstoreHistoryTableColumnTimestamp,
		pstoreHistoryTableColumnEventName,
		pstoreHistoryTableColumnMessage,
		pstoreHistoryTableColumnRawMessage,
	))
	if err != nil {
		_ = tx.Rollback()
		return err
	}

	_, err = tx.ExecContext(ctx, fmt.Sprintf(`CREATE INDEX IF NOT EXISTS idx_%s_%s ON %s(%s);`,
		tableName, pstoreHistoryTableColumnTimestamp, tableName, pstoreHistoryTableColumnTimestamp))
	if err != nil {
		_ = tx.Rollback()
		return err
	}

	_, err = tx.ExecContext(ctx, fmt.Sprintf(`CREATE INDEX IF NOT EXISTS idx_%s_%s ON %s(%s);`,
		tableName, pstoreHistoryTableColumnRawMessage, tableName, pstoreHistoryTableColumnRawMessage))
	if err != nil {
		_ = tx.Rollback()
		return err
	}

	return tx.Commit()
}

func insertHistory(ctx context.Context, dbRW *sql.DB, tableName string, h *History) error {
	tx, err := dbRW.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	_, err = tx.ExecContext(
		ctx,
		fmt.Sprintf(`INSERT INTO %s (%s, %s, %s, %s) VALUES (?, ?, ?, ?);`,
			tableName,
			pstoreHistoryTableColumnTimestamp,
			pstoreHistoryTableColumnEventName,
			pstoreHistoryTableColumnMessage,
			pstoreHistoryTableColumnRawMessage,
		),
		h.Timestamp, h.EventName, h.Message, h.RawMessage,
	)
	if err != nil {
		_ = tx.Rollback()
		return err
	}

	return tx.Commit()
}

// findHistoryByRawMessage finds the history with the raw message, and returns the matching counts
func findHistoryByRawMessage(ctx context.Context, dbRO *sql.DB, tableName string, rawMessage string, since time.Time) (int, error) {
	rows, err := dbRO.QueryContext(ctx, fmt.Sprintf(`SELECT COUNT(*) FROM %s WHERE %s = ? AND %s >= ?;`,
		tableName, pstoreHistoryTableColumnRawMessage, pstoreHistoryTableColumnTimestamp,
	), rawMessage, since.Unix())
	if err != nil {
		return 0, err
	}
	defer rows.Close()

	if !rows.Next() {
		return 0, nil
	}

	var count int
	if err := rows.Scan(&count); err != nil {
		return 0, err
	}

	return count, nil
}

func purgeHistory(ctx context.Context, dbRW *sql.DB, tableName string, before time.Time) error {
	tx, err := dbRW.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	rs, err := tx.ExecContext(ctx, fmt.Sprintf(`DELETE FROM %s WHERE %s < ?;`, tableName, pstoreHistoryTableColumnTimestamp), before.Unix())
	if err != nil {
		_ = tx.Rollback()
		return err
	}

	deleted, err := rs.RowsAffected()
	if err != nil {
		_ = tx.Rollback()
		return err
	}
	log.Logger.Infow("purged pstore history", "table", tableName, "before", before, "affected", deleted)

	return tx.Commit()
}
