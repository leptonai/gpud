<style>
.header {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    background-color: #f5f5f7;
    padding: 20px 0;
    text-align: center;
    border-bottom: 1px solid #d2d2d7;
    margin-bottom: 30px;
}

.header h1 {
    font-size: 28px;
    font-weight: 500;
    color: #1d1d1f;
    margin: 0;
}

.header p {
    font-size: 16px;
    color: #515154;
    margin: 5px 0 0;
}

.system-info {
    display: flex;
    justify-content: space-around;
    flex-wrap: wrap;
    margin: 20px 0;
    padding: 0 20px;
}

.info-card {
    background-color: #ffffff;
    border: 1px solid #d2d2d7;
    border-radius: 12px;
    padding: 24px;
    margin: 10px;
    flex: 1;
    min-width: 250px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

.info-card h3 {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    font-size: 20px;
    font-weight: 600;
    color: #1d1d1f;
    margin-bottom: 16px;
    border-bottom: 1px solid #d2d2d7;
    padding-bottom: 12px;
}

.info-card p {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    font-size: 14px;
    line-height: 1.4;
    color: #515154;
    margin: 8px 0;
}

.info-card strong {
    font-weight: 600;
    color: #1d1d1f;
}

@media (max-width: 768px) {
    .system-info {
        flex-direction: column;
    }
}



/* /v1/states */

.workloads-section {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    margin-top: 30px;
    padding: 20px;
    background-color: #f5f5f7;
    border-radius: 8px;
}

.workloads-section h2 {
    font-size: 24px;
    color: #1d1d1f;
    margin-bottom: 20px;
}

.states-section {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    margin-top: 30px;
    padding: 20px;
    background-color: #f5f5f7;
    border-radius: 8px;
}

.states-section h2 {
    font-size: 24px;
    color: #1d1d1f;
    margin-bottom: 20px;
}

.component-states {
    background-color: #ffffff;
    border: 1px solid #d2d2d7;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 20px;
}

.component-states h3 {
    font-size: 18px;
    color: #1d1d1f;
    margin-bottom: 10px;
}

.state-item {
    margin-bottom: 10px;
    padding: 10px;
    border-radius: 5px;
}

.state-item.healthy {
    background-color: #e8f5e9;
    color: #1b5e20;
}

.state-item.unhealthy {
    background-color: #ffebee;
    color: #b71c1c;
}

.state-item ul {
    margin-top: 5px;
    padding-left: 20px;
}

.state-item li {
    font-size: 14px;
}

.yaml-error, .yaml-reason {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    font-size: 12px;
    width: 100%;
    max-height: 200px;
    border-radius: 6px;
    padding: 10px;
    margin-top: 8px;
    white-space: pre-wrap;
    overflow-y: auto;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
    transition: all 0.3s cubic-bezier(.25,.8,.25,1);
}

.yaml-error {
    background-color: #fef1f2;
    border: 1px solid #fee2e2;
    color: #991b1b;
}

.yaml-reason {
    background-color: #f3f4f6;
    border: 1px solid #e5e7eb;
    color: #1f2937;
}

@media (max-width: 768px) {
    .yaml-error, .yaml-reason {
        font-size: 11px;
        padding: 8px;
        max-height: 150px;
    }
}

.yaml-error:hover, .yaml-reason:hover {
    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
}

/* Add custom scrollbar for webkit browsers */
.yaml-error::-webkit-scrollbar, .yaml-reason::-webkit-scrollbar {
    width: 8px;
}

.yaml-error::-webkit-scrollbar-thumb, .yaml-reason::-webkit-scrollbar-thumb {
    background-color: rgba(0,0,0,0.2);
    border-radius: 4px;
}

.yaml-error::-webkit-scrollbar-track, .yaml-reason::-webkit-scrollbar-track {
    background-color: rgba(0,0,0,0.1);
    border-radius: 4px;
}


/* /v1/events */

.events-section {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    margin-top: 30px;
    padding: 20px;
    background-color: #f5f5f7;
    border-radius: 8px;
}

.events-section h2 {
    font-size: 24px;
    color: #1d1d1f;
    margin-bottom: 20px;
}

.component-events {
    background-color: #ffffff;
    border: 1px solid #d2d2d7;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 20px;
}

.component-events h3 {
    font-size: 18px;
    color: #1d1d1f;
    margin-bottom: 10px;
}

.event-item {
    margin-bottom: 10px;
    padding: 10px;
    border-radius: 5px;
}

.event-item.healthy {
    background-color: #e8f5e9;
    color: #1b5e20;
}

.event-item.unhealthy {
    background-color: #ffebee;
    color: #b71c1c;
}

.event-item ul {
    margin-top: 5px;
    padding-left: 20px;
}

.event-item li {
    font-size: 14px;
}

.events-summary {
    font-size: 14px;
    color: #666;
    margin: 5px 0 10px;
}



/* /v1/metrics */
.chart-title {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    font-size: 18px;
    font-weight: 500;
    color: #1d1d1f;
    margin-bottom: 15px;
}

.charts-row {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    margin: 0 -10px; /* Negative margin to counteract padding on chart containers */
}

.chart-container {
    flex: 1 1 calc(50% - 20px); /* 50% width minus padding */
    min-width: 300px; /* Minimum width before wrapping */
    margin: 10px;
    /* ... existing chart-container styles ... */
}

@media (max-width: 768px) {
    .chart-container {
        flex: 1 1 100%; /* Full width on smaller screens */
    }
}

{{if .NVIDIAGPUUtilChart}}
#nvidia-gpu-util-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}

{{if .NVIDIAMemoryChart}}
#nvidia-memory-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}

{{if .NVIDIATemperatureChart}}
#nvidia-temperature-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}

{{if .NVIDIAPowerChart}}
#nvidia-power-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}

{{if .NVIDIAClockSpeedChart}}
#nvidia-clock-speed-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}

{{if .NVIDIAErrsChart}}
#nvidia-errs-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}

{{if .CPUChart}}
#cpu-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}

{{if .MemoryChart}}
#memory-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}

{{if .FDChart}}
#fd-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}

{{if .DiskChart}}
#disk-chart {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
}
{{end}}



/* system resources */
.section-header {
    font-size: 18px;
    color: #1d1d1f;
    margin-bottom: 12px;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
}

.section-header:hover {
    color: #0070c9;
}

.system-resources-section {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    margin-top: 30px;
    padding: 0 20px;
}

#systemStatesWorkloadsArrow {
    margin-left: 10px;
    font-size: 18px;
}

#systemStatesNonWorkloadsArrow {
    margin-left: 10px;
    font-size: 18px;
}

#systemEventsArrow {
    margin-left: 10px;
    font-size: 18px;
}

#systemResourcesArrow {
    margin-left: 10px;
    font-size: 18px;
}

.workloads-summary {
    font-size: 14px;
    color: #666;
    margin: 5px 0 10px;
}

.states-summary {
    font-size: 14px;
    color: #666;
    margin: 5px 0 10px;
}


/* gpud self info */
.footer {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    background-color: #f5f5f7;
    border-top: 1px solid #d2d2d7;
    padding: 20px 0;
    margin-top: 30px;
}

.footer-content {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

.footer-section {
    flex: 1;
    min-width: 200px;
    margin: 10px;
}

.footer-section h3 {
    font-size: 18px;
    color: #1d1d1f;
    margin-bottom: 10px;
}

.footer-section p {
    font-size: 14px;
    color: #515154;
    margin: 5px 0;
}

@media (max-width: 768px) {
    .footer-content {
        flex-direction: column;
    }

    .footer-section {
        margin: 10px 0;
    }
}



/* for admin panel */
#result-container {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    max-width: 800px;
    margin-top: 30px;
    background-color: #ffffff;
    border: 1px solid #d2d2d7;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.result-header {
    font-size: 20px;
    font-weight: 500;
    color: #1d1d1f;
    padding: 15px 20px;
    margin: 0;
    border-bottom: 1px solid #d2d2d7;
    background-color: #f5f5f7;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
}

#result pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    max-width: 800px;
    margin: 0;
    background-color: #f4f4f4;
    padding: 15px;
    border-radius: 5px;
}

.form-container {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    max-width: 400px;
    margin-top: 20px;
}

.form-section {
    margin-bottom: 20px;
}

.form-title {
    font-weight: 600;
    margin-bottom: 10px;
}

.radio-group {
    display: flex;
    flex-direction: column;
}

.radio-group.inline {
    flex-direction: row;
}

.radio-group.inline .radio-label {
    margin-right: 15px;
}

.radio-group.inline .radio-label:last-child {
    margin-right: 0;
}

.radio-label {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    cursor: pointer;
}

.radio-input {
    margin-right: 8px;
    width: 20px; /* Increase width */
    height: 20px; /* Increase height */
}

.path-info {
    display: flex;
    flex-direction: column;
    margin-left: 8px;
}

.path-code {
    font-family: monospace;
    background-color: #f0f0f0;
    padding: 2px 4px;
    border-radius: 2px;
    font-size: 14px;
}

.path-description {
    font-size: 14px;
    color: #666;
    margin-top: 2px;
}

/* Add media query for mobile responsiveness */
@media (max-width: 600px) {
    .radio-group {
        flex-direction: column;
    }

    .radio-label {
        flex-direction: column;
        align-items: flex-start;
    }

    .path-info {
        margin-left: 0;
    }

    .radio-input {
        width: 24px; /* Further increase width for mobile */
        height: 24px; /* Further increase height for mobile */
    }

    .radio-label {
        font-size: 18px; /* Increase font size for better readability */
    }
}
</style>

<script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>

<script>
function toggleStatesWorkloads() {
    const workloadsContainer = document.getElementById('workloads-container');
    const arrow = document.getElementById('systemStatesWorkloadsArrow');
    if (workloadsContainer.style.display === 'none') {
        workloadsContainer.style.display = 'block';
        arrow.textContent = '▲';
    } else {
        workloadsContainer.style.display = 'none';
        arrow.textContent = '▼';
    }
}

function toggleStatesNonWorkloads() {
    const statesContainer = document.getElementById('states-container');
    const arrow = document.getElementById('systemStatesNonWorkloadsArrow');
    if (statesContainer.style.display === 'none') {
        statesContainer.style.display = 'block';
        arrow.textContent = '▲';
    } else {
        statesContainer.style.display = 'none';
        arrow.textContent = '▼';
    }
}

function toggleSystemEvents() {
    const eventsContainer = document.getElementById('events-container');
    const arrow = document.getElementById('systemEventsArrow');
    if (eventsContainer.style.display === 'none') {
        eventsContainer.style.display = 'block';
        arrow.textContent = '▲';
    } else {
        eventsContainer.style.display = 'none';
        arrow.textContent = '▼';
    }
}

function toggleSystemResources() {
    const charts = document.getElementById('systemResourcesCharts');
    const arrow = document.getElementById('systemResourcesArrow');
    if (charts.style.display === 'none') {
        charts.style.display = 'block';
        arrow.textContent = '▲';
    } else {
        charts.style.display = 'none';
        arrow.textContent = '▼';
    }
    // Trigger window resize to redraw charts
    window.dispatchEvent(new Event('resize'));
}

function fetchAndDisplayStates() {
    fetch('/v1/states', {
        headers: {
            'Content-Type': 'application/json',
            'Accept-Encoding': 'gzip'
        }
    })
    .then(response => response.json())
    .then(data => {
        const workloadsContainer = document.getElementById('workloads-container');
        workloadsContainer.innerHTML = ''; // Clear existing content
        const workloadsSummary = document.getElementById('workloads-summary');

        const statesContainer = document.getElementById('states-container');
        statesContainer.innerHTML = ''; // Clear existing content
        const statesSummary = document.getElementById('states-summary');

        // Sort components based on their overall health status, then lexicographically
        data.sort((a, b) => {
            const aHasUnhealthy = a.states.some(state => !state.healthy);
            const bHasUnhealthy = b.states.some(state => !state.healthy);
            if (bHasUnhealthy !== aHasUnhealthy) {
                return bHasUnhealthy - aHasUnhealthy;
            }
            // If health status is the same, sort lexicographically by component name
            return a.component.localeCompare(b.component);
        });

        let nonWorkloadsHealthyCount = 0;
        let nonWorkloadsUnhealthyCount = 0;
        let nonWorkloadsTotalStates = 0;
        const workloadsData = [];
        data.forEach(component => {
            if (component.component === 'accelerator-nvidia-processes' || component.component === 'containerd-pod' || component.component === 'docker-container' || component.component === 'k8s-pod') {
                workloadsData.push(component);
                return;
            }

            const statesList = document.createElement('ul');
            component.states.sort((a, b) => b.healthy - a.healthy); // Sort states to display unhealthy ones first
            component.states.forEach(state => {
                nonWorkloadsTotalStates++;
                if (state.healthy) {
                    nonWorkloadsHealthyCount++;
                } else {
                    nonWorkloadsUnhealthyCount++;
                }

                const stateItem = document.createElement('li');
                stateItem.className = `state-item ${state.healthy ? 'healthy' : 'unhealthy'}`;

                let stateContent = `<strong>${state.name}</strong>: `;
                if (state.healthy !== undefined) {
                    stateContent += state.healthy ? 'Healthy' : 'Unhealthy';
                }

                if (state.error) {
                    stateContent += `<br><div class="yaml-error">${state.error}</div>`;
                }
                if (state.reason) {
                    stateContent += `<br><div class="yaml-reason">${state.reason}</div>`;
                }

                stateItem.innerHTML = stateContent;
                statesList.appendChild(stateItem);
            });

            const componentDiv = document.createElement('div');
            componentDiv.className = 'component-states';
            const componentTitle = document.createElement('h3');
            componentTitle.textContent = component.component;
            componentDiv.appendChild(componentTitle);
            componentDiv.appendChild(statesList);
            statesContainer.appendChild(componentDiv);
        });


        let workloadsTotalStates = 0;
        if (workloadsData.length > 0) {
            workloadsData.forEach(component => {
                const statesList = document.createElement('ul');
                component.states.forEach(state => {
                    workloadsTotalStates++;

                    const stateItem = document.createElement('li');
                    stateItem.className = `state-item ${state.healthy ? 'healthy' : 'unhealthy'}`;

                    let stateContent = `<strong>${state.name}</strong>: `;

                    // NOTE: do not show healthy/unhealthy for workloads
                    if (state.healthy !== undefined) {
                        stateContent += state.healthy ? 'Healthy' : 'Unhealthy';
                    }

                    if (state.error) {
                        stateContent += `<br><div class="yaml-error">${state.error}</div>`;
                    }
                    if (state.reason) {
                        stateContent += `<br><div class="yaml-reason">${state.reason}</div>`;
                    }

                    stateItem.innerHTML = stateContent;
                    statesList.appendChild(stateItem);
                });

                const componentDiv = document.createElement('div');
                componentDiv.className = 'component-states';
                const componentTitle = document.createElement('h3');
                componentTitle.textContent = component.component;
                componentDiv.appendChild(componentTitle);
                componentDiv.appendChild(statesList);
                workloadsContainer.appendChild(componentDiv);
            });
        }

        // update summary
        workloadsSummary.textContent = `total ${workloadsTotalStates} workload kinds ✅`;
        statesSummary.textContent = `${nonWorkloadsHealthyCount} healthy, ${nonWorkloadsUnhealthyCount} unhealthy, out of ${nonWorkloadsTotalStates} states ${nonWorkloadsUnhealthyCount === 0 ? '✅' : '🚨'}`;
    })
    .catch(error => {
        console.error('Error fetching states:', error);
    })
    .finally(() => {
        // Schedule the next update
        setTimeout(fetchAndDisplayStates, {{.RefreshPeriodInMilliseconds}});
    });
}

function fetchAndDisplayEvents() {
    fetch('/v1/events', {
        headers: {
            'Content-Type': 'application/json',
            'Accept-Encoding': 'gzip'
        }
    })
    .then(response => response.json())
    .then(data => {
        const eventsContainer = document.getElementById('events-container');
        eventsContainer.innerHTML = ''; // Clear existing content

        const eventsSummary = document.getElementById('events-summary');

        let unhealthyCount = 0;
        let totalEvents = 0;

        // Sort components: unhealthy first, then by component name
        data.sort((a, b) => {
            if ((a.events !== null) !== (b.events !== null)) {
                return (b.events !== null) - (a.events !== null);
            }
            return a.component.localeCompare(b.component);
        });

        data.forEach(component => {
            totalEvents++;
            if (component.events !== null) {
                unhealthyCount++;
            }

            const componentDiv = document.createElement('div');
            componentDiv.className = 'component-events';

            const componentTitle = document.createElement('h3');
            componentTitle.textContent = component.component;
            componentDiv.appendChild(componentTitle);

            const eventsList = document.createElement('ul');
            const eventItem = document.createElement('li');
            eventItem.className = `event-item ${component.events === null ? 'healthy' : 'unhealthy'}`;

            let eventContent = `<strong>Status:</strong> ${component.events === null ? 'Healthy' : 'Unhealthy'}<br>`;
            eventContent += `<strong>Start time:</strong> ${new Date(component.startTime).toLocaleString()}<br>`;
            eventContent += `<strong>End time:</strong> ${new Date(component.endTime).toLocaleString()}<br>`;

            if (component.events !== null) {
                eventContent += '<strong>Events:</strong><ul>';
                component.events.forEach(event => {
                    eventContent += `<li>${event}</li>`;
                });
                eventContent += '</ul>';
            }

            eventItem.innerHTML = eventContent;
            eventsList.appendChild(eventItem);

            componentDiv.appendChild(eventsList);
            eventsContainer.appendChild(componentDiv);
        });

        // Update summary
        eventsSummary.textContent = `${unhealthyCount} event(s), out of total ${totalEvents} components ${unhealthyCount === 0 ? '✅' : '🚨'}`;
    })
    .catch(error => {
        console.error('Error fetching events:', error);
    })
    .finally(() => {
        // Schedule the next update
        setTimeout(fetchAndDisplayEvents, {{.RefreshPeriodInMilliseconds}});
    });
}

{{if .Admin}}
function handleRadioChange(radio) {
    const format = document.querySelector('input[name="format"]:checked').value;
    const contentType = format === 'json' ? 'application/json' : 'application/yaml';

    fetch(radio.value, {
            headers: {
                'Content-Type': contentType,
                'json-indent': "true"
            }
        })
        .then(response => response.text())
        .then(data => {
            document.querySelector('.result-header').textContent = radio.value + ' (' + format + ')';
            document.getElementById('result').innerHTML = '<pre>' + data + '</pre>';
        })
        .catch(error => {
            console.error('Error:', error);
        });
}
{{end}}

function renderChartsFromMetrics() {
    fetch('/v1/metrics?since={{.MetricsSincePeriod}}&components={{.Components}}', {
        headers: {
            'Content-Type': 'application/json',
            'Accept-Encoding': 'gzip'
        }
    })
    .then(response => response.json())
    .then(data => {
{{if .NVIDIAGPUUtilChart}}
        const nvidiaGPUUtilData = data.find(item => item.component === 'accelerator-nvidia-utilization');
        if (nvidiaGPUUtilData) {
            createNVIDIAGPUUtilChart(nvidiaGPUUtilData.metrics);
        }
{{end}}
{{if .NVIDIAMemoryChart}}
        const nvidiaMemoryData = data.find(item => item.component === 'accelerator-nvidia-memory');
        if (nvidiaMemoryData) {
            createNVIDIAMemoryChart(nvidiaMemoryData.metrics);
        }
{{end}}
{{if .NVIDIATemperatureChart}}
        const nvidiaTemperatureData = data.find(item => item.component === 'accelerator-nvidia-temperature');
        if (nvidiaTemperatureData) {
            createNVIDIATemperatureChart(nvidiaTemperatureData.metrics);
        }
{{end}}
{{if .NVIDIAPowerChart}}
        const nvidiaPowerData = data.find(item => item.component === 'accelerator-nvidia-power');
        if (nvidiaPowerData) {
            createNVIDIAPowerChart(nvidiaPowerData.metrics);
        }
{{end}}
{{if .NVIDIAClockSpeedChart}}
        const nvidiaClockSpeedData = data.find(item => item.component === 'accelerator-nvidia-clock-speed');
        if (nvidiaClockSpeedData) {
            createNVIDIAClockSpeedChart(nvidiaClockSpeedData.metrics);
        }
{{end}}
{{if .NVIDIAErrsChart}}
        const nvidiaErrs = data.filter(item =>
            item.component === 'accelerator-nvidia-clock' ||
            item.component === 'accelerator-nvidia-ecc');
        if (nvidiaErrs.length > 0) {
            const allNvidiaMetrics = nvidiaErrs.flatMap(item => item.metrics);
            createNVIDIAErrsChart(allNvidiaMetrics);
        }
{{end}}
{{if .CPUChart}}
        const cpuData = data.find(item => item.component === 'cpu');
        if (cpuData) {
            createCPUChart(cpuData.metrics);
        }
{{end}}
{{if .MemoryChart}}
        const memData = data.find(item => item.component === 'memory');
        if (memData) {
            createMemoryChart(memData.metrics);
        }
{{end}}
{{if .FDChart}}
        const fdData = data.find(item => item.component === 'file-descriptor');
        if (fdData) {
            createFDChart(fdData.metrics);
        }
{{end}}
{{if .DiskChart}}
        const diskData = data.find(item => item.component === 'disk');
        if (diskData) {
            createDiskChart(diskData.metrics);
        }
{{end}}
    })
    .catch(error => {
        console.error('Error fetching metrics:', error);
    })
    .finally(() => {
        // Schedule the next update
        setTimeout(renderChartsFromMetrics, {{.RefreshPeriodInMilliseconds}});
    });
}

{{if .NVIDIAGPUUtilChart}}
function createNVIDIAGPUUtilChart(metrics) {
    const gpuUtils = metrics.filter(m => m.metric_name === 'accelerator_nvidia_utilization_gpu_util_percent');

    // group by gpu_id
    const groupedMetrics = {};
    gpuUtils.forEach((entry, index) => {
        const gpuID = entry.extra_info.gpu_id;
        if (!groupedMetrics[gpuID]) {
            groupedMetrics[gpuID] = { gpuUtils: [] };
        }
        groupedMetrics[gpuID].gpuUtils.push(entry);
    });

    const series = Object.keys(groupedMetrics).map(gpuID => {
        const gpuUtils = groupedMetrics[gpuID].gpuUtils;
        const chartData = gpuUtils.map((gpuUtilEntry, index) => {
            return [
                gpuUtilEntry.unix_seconds * 1000,
                gpuUtilEntry.value
            ];
        });
        return [
        {
                name: `GPU util (${gpuID})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[1]])
            }
        ];
    }).flat();

    const chart = echarts.init(document.getElementById('nvidia-gpu-util-chart'));
    const option = {
        title: {
            text: 'NVIDIA GPU Utilization'
        },
        grid: {
            left: '10%',
            right: '5%',
            bottom: '15%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                let result = `<div style="font-weight: bold; margin-bottom: 3px; font-size: 10px;">${date.toLocaleString()}</div>`;

                const gpuData = {};
                params.forEach(param => {
                    const [type, gpuId] = param.seriesName.split(' (');
                    const gpu = gpuId.slice(0, -1); // Remove the closing parenthesis
                    if (!gpuData[gpu]) {
                        gpuData[gpu] = {};
                    }
                    gpuData[gpu][type] = `${param.value[1].toFixed(2)} %`;
                });

                const gpus = Object.keys(gpuData);
                for (let i = 0; i < gpus.length; i += 4) {
                    result += '<div style="display: flex; justify-content: flex-start; margin-top: 2px;">';
                    for (let j = i; j < Math.min(i + 4, gpus.length); j++) {
                        const gpu = gpus[j];
                        const data = gpuData[gpu];
                        result += `
                            <div style="flex: 0 0 23%; margin: 0 1px; padding: 2px; border: 1px solid #ccc; border-radius: 2px; font-size: 9px;">
                                <div style="font-weight: bold; margin-bottom: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${gpu.length > 7 ? gpu.substring(0, 7) + '..' : gpu}</div>
                                <div style="line-height: 1.2;">${Object.entries(data).map(([type, value]) => `${type}: ${value}`).join('<br>')}</div>
                            </div>
                        `;
                    }
                    result += '</div>';
                }

                return result;
            }
        },
        legend: {
            data: series.map(s => s.name),
            type: 'scroll',
            orient: 'horizontal',
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Util (%)'
        },
        series: series
    };
    chart.setOption(option);
    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

{{if .NVIDIAMemoryChart}}
function createNVIDIAMemoryChart(metrics) {
    const totalBytes = metrics.filter(m => m.metric_name === 'accelerator_nvidia_memory_total_bytes');
    const usedBytes = metrics.filter(m => m.metric_name === 'accelerator_nvidia_memory_used_bytes');

    // group by gpu_id
    const groupedMetrics = {};
    totalBytes.forEach((entry, index) => {
        const gpuID = entry.extra_info.gpu_id;
        if (!groupedMetrics[gpuID]) {
            groupedMetrics[gpuID] = { total: [], used: [] };
        }
        groupedMetrics[gpuID].total.push(entry);
        groupedMetrics[gpuID].used.push(usedBytes[index]);
    });

    const series = Object.keys(groupedMetrics).map(gpuID => {
        const total = groupedMetrics[gpuID].total;
        const used = groupedMetrics[gpuID].used;
        const chartData = total.map((totalEntry, index) => {
            return [
                totalEntry.unix_seconds * 1000,
                totalEntry.value / (1024 * 1024 * 1024), // Convert to GB
                used[index].value / (1024 * 1024 * 1024) // Convert to GB
            ];
        });
        return [
        {
                name: `Total (${gpuID})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[1]])
            },
            {
                name: `Used (${gpuID})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[2]])
            }
        ];
    }).flat();

    const chart = echarts.init(document.getElementById('nvidia-memory-chart'));
    const option = {
        title: {
            text: 'NVIDIA GPU Memory'
        },
        grid: {
            left: '10%',
            right: '5%',
            bottom: '15%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                let result = `<div style="font-weight: bold; margin-bottom: 3px; font-size: 10px;">${date.toLocaleString()}</div>`;

                const gpuData = {};
                params.forEach(param => {
                    const [type, gpuId] = param.seriesName.split(' (');
                    const gpu = gpuId.slice(0, -1); // Remove the closing parenthesis
                    if (!gpuData[gpu]) {
                        gpuData[gpu] = {};
                    }
                    gpuData[gpu][type] = `${param.value[1].toFixed(2)} GB`;
                });

                const gpus = Object.keys(gpuData);
                for (let i = 0; i < gpus.length; i += 4) {
                    result += '<div style="display: flex; justify-content: flex-start; margin-top: 2px;">';
                    for (let j = i; j < Math.min(i + 4, gpus.length); j++) {
                        const gpu = gpus[j];
                        const data = gpuData[gpu];
                        result += `
                            <div style="flex: 0 0 23%; margin: 0 1px; padding: 2px; border: 1px solid #ccc; border-radius: 2px; font-size: 9px;">
                                <div style="font-weight: bold; margin-bottom: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${gpu.length > 7 ? gpu.substring(0, 7) + '..' : gpu}</div>
                                <div style="line-height: 1.2;">${Object.entries(data).map(([type, value]) => `${type}: ${value}`).join('<br>')}</div>
                            </div>
                        `;
                    }
                    result += '</div>';
                }

                return result;
            }
        },
        legend: {
            data: series.map(s => s.name),
            type: 'scroll',
            orient: 'horizontal',
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Memory (GB)'
        },
        series: series
    };
    chart.setOption(option);
    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

{{if .NVIDIATemperatureChart}}
function createNVIDIATemperatureChart(metrics) {
    const slowdownThresholds = metrics.filter(m => m.metric_name === 'accelerator_nvidia_temperature_slowdown_threshold_celsius');
    const currentTemperatures = metrics.filter(m => m.metric_name === 'accelerator_nvidia_temperature_current_celsius');

    // group by gpu_id
    const groupedMetrics = {};
    slowdownThresholds.forEach((entry, index) => {
        const gpuID = entry.extra_info.gpu_id;
        if (!groupedMetrics[gpuID]) {
            groupedMetrics[gpuID] = { slowdownThresholds: [], currentCelsius: [] };
        }
        groupedMetrics[gpuID].slowdownThresholds.push(entry);
        groupedMetrics[gpuID].currentCelsius.push(currentTemperatures[index]);
    });

    const series = Object.keys(groupedMetrics).map(gpuID => {
        const slowdownThresholds = groupedMetrics[gpuID].slowdownThresholds;
        const currentCelsius = groupedMetrics[gpuID].currentCelsius;
        const chartData = slowdownThresholds.map((slowdownThresholdsEntry, index) => {
            return [
                slowdownThresholdsEntry.unix_seconds * 1000,
                slowdownThresholdsEntry.value,
                currentCelsius[index].value
            ];
        });
        return [
        {
                name: `Slowdown threshold (${gpuID})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[1]])
            },
            {
                name: `Current (${gpuID})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[2]])
            }
        ];
    }).flat();

    const chart = echarts.init(document.getElementById('nvidia-temperature-chart'));
    const option = {
        title: {
            text: 'NVIDIA GPU Temperature'
        },
        grid: {
            left: '10%',
            right: '5%',
            bottom: '15%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                let result = `<div style="font-weight: bold; margin-bottom: 3px; font-size: 10px;">${date.toLocaleString()}</div>`;

                const gpuData = {};
                params.forEach(param => {
                    const [type, gpuId] = param.seriesName.split(' (');
                    const gpu = gpuId.slice(0, -1); // Remove the closing parenthesis
                    if (!gpuData[gpu]) {
                        gpuData[gpu] = {};
                    }
                    gpuData[gpu][type] = `${param.value[1].toFixed(2)} °C`;
                });

                const gpus = Object.keys(gpuData);
                for (let i = 0; i < gpus.length; i += 4) {
                    result += '<div style="display: flex; justify-content: flex-start; margin-top: 2px;">';
                    for (let j = i; j < Math.min(i + 4, gpus.length); j++) {
                        const gpu = gpus[j];
                        const data = gpuData[gpu];
                        result += `
                            <div style="flex: 0 0 23%; margin: 0 1px; padding: 2px; border: 1px solid #ccc; border-radius: 2px; font-size: 9px;">
                                <div style="font-weight: bold; margin-bottom: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${gpu.length > 7 ? gpu.substring(0, 7) + '..' : gpu}</div>
                                <div style="line-height: 1.2;">${Object.entries(data).map(([type, value]) => `${type}: ${value}`).join('<br>')}</div>
                            </div>
                        `;
                    }
                    result += '</div>';
                }

                return result;
            }
        },
        legend: {
            data: series.map(s => s.name),
            type: 'scroll',
            orient: 'horizontal',
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Temperature (°C)'
        },
        series: series
    };
    chart.setOption(option);
    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

{{if .NVIDIAPowerChart}}
function createNVIDIAPowerChart(metrics) {
    const enforcedLimits = metrics.filter(m => m.metric_name === 'accelerator_nvidia_power_enforced_limit_milli_watts');
    const currentUsages = metrics.filter(m => m.metric_name === 'accelerator_nvidia_power_current_usage_milli_watts');

    // group by gpu_id
    const groupedMetrics = {};
    enforcedLimits.forEach((entry, index) => {
        const gpuID = entry.extra_info.gpu_id;
        if (!groupedMetrics[gpuID]) {
            groupedMetrics[gpuID] = { enforceLimitMilliWatts: [], currentUsageMilliWatts: [] };
        }
        groupedMetrics[gpuID].enforceLimitMilliWatts.push(entry);
        groupedMetrics[gpuID].currentUsageMilliWatts.push(currentUsages[index]);
    });

    const series = Object.keys(groupedMetrics).map(gpuID => {
        const enforceLimitMilliWatts = groupedMetrics[gpuID].enforceLimitMilliWatts;
        const currentUsageMilliWatts = groupedMetrics[gpuID].currentUsageMilliWatts;
        const chartData = enforceLimitMilliWatts.map((enforceLimitMilliWattsEntry, index) => {
            return [
                enforceLimitMilliWattsEntry.unix_seconds * 1000,
                enforceLimitMilliWattsEntry.value / 1000,
                currentUsageMilliWatts[index].value / 1000
            ];
        });
        return [
        {
                name: `Limit (${gpuID})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[1]])
            },
            {
                name: `Current (${gpuID})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[2]])
            }
        ];
    }).flat();

    const chart = echarts.init(document.getElementById('nvidia-power-chart'));
    const option = {
        title: {
            text: 'NVIDIA GPU Power'
        },
        grid: {
            left: '10%',
            right: '5%',
            bottom: '15%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                let result = `<div style="font-weight: bold; margin-bottom: 3px; font-size: 10px;">${date.toLocaleString()}</div>`;

                const gpuData = {};
                params.forEach(param => {
                    const [type, gpuId] = param.seriesName.split(' (');
                    const gpu = gpuId.slice(0, -1); // Remove the closing parenthesis
                    if (!gpuData[gpu]) {
                        gpuData[gpu] = {};
                    }
                    gpuData[gpu][type] = `${param.value[1].toFixed(2)} W`;
                });

                const gpus = Object.keys(gpuData);
                for (let i = 0; i < gpus.length; i += 4) {
                    result += '<div style="display: flex; justify-content: flex-start; margin-top: 2px;">';
                    for (let j = i; j < Math.min(i + 4, gpus.length); j++) {
                        const gpu = gpus[j];
                        const data = gpuData[gpu];
                        result += `
                            <div style="flex: 0 0 23%; margin: 0 1px; padding: 2px; border: 1px solid #ccc; border-radius: 2px; font-size: 9px;">
                                <div style="font-weight: bold; margin-bottom: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${gpu.length > 7 ? gpu.substring(0, 7) + '..' : gpu}</div>
                                <div style="line-height: 1.2;">${Object.entries(data).map(([type, value]) => `${type}: ${value}`).join('<br>')}</div>
                            </div>
                        `;
                    }
                    result += '</div>';
                }

                return result;
            }
        },
        legend: {
            data: series.map(s => s.name),
            type: 'scroll',
            orient: 'horizontal',
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Power (W)'
        },
        series: series
    };
    chart.setOption(option);
    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

{{if .NVIDIAClockSpeedChart}}
function createNVIDIAClockSpeedChart(metrics) {
    const graphicsMHzs = metrics.filter(m => m.metric_name === 'accelerator_nvidia_clock_speed_graphics_mhz');

    // group by gpu_id
    const groupedMetrics = {};
    graphicsMHzs.forEach((entry, index) => {
        const gpuID = entry.extra_info.gpu_id;
        if (!groupedMetrics[gpuID]) {
            groupedMetrics[gpuID] = { graphicsMHzs: [] };
        }
        groupedMetrics[gpuID].graphicsMHzs.push(entry);
    });

    const series = Object.keys(groupedMetrics).map(gpuID => {
        const graphicsMHzs = groupedMetrics[gpuID].graphicsMHzs;
        const chartData = graphicsMHzs.map((graphicsMHzsEntry, index) => {
            return [
                graphicsMHzsEntry.unix_seconds * 1000,
                graphicsMHzsEntry.value
                // memoryMHzs[index].value
            ];
        });
        return [
            {
                name: `Graphics (${gpuID})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[1]])
            }
        ];
    }).flat();

    const chart = echarts.init(document.getElementById('nvidia-clock-speed-chart'));
    const option = {
        title: {
            text: 'NVIDIA GPU Clock Speed'
        },
        grid: {
            left: '10%',
            right: '5%',
            bottom: '15%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                let result = `<div style="font-weight: bold; margin-bottom: 3px; font-size: 10px;">${date.toLocaleString()}</div>`;

                const gpuData = {};
                params.forEach(param => {
                    const [type, gpuId] = param.seriesName.split(' (');
                    const gpu = gpuId.slice(0, -1); // Remove the closing parenthesis
                    if (!gpuData[gpu]) {
                        gpuData[gpu] = {};
                    }
                    gpuData[gpu][type] = `${param.value[1]}`;
                });

                const gpus = Object.keys(gpuData);
                for (let i = 0; i < gpus.length; i += 4) {
                    result += '<div style="display: flex; justify-content: flex-start; margin-top: 2px;">';
                    for (let j = i; j < Math.min(i + 4, gpus.length); j++) {
                        const gpu = gpus[j];
                        const data = gpuData[gpu];
                        result += `
                            <div style="flex: 0 0 23%; margin: 0 1px; padding: 2px; border: 1px solid #ccc; border-radius: 2px; font-size: 9px;">
                                <div style="font-weight: bold; margin-bottom: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${gpu.length > 7 ? gpu.substring(0, 7) + '..' : gpu}</div>
                                <div style="line-height: 1.2;">${Object.entries(data).map(([type, value]) => `${type}: ${value}`).join('<br>')}</div>
                            </div>
                        `;
                    }
                    result += '</div>';
                }

                return result;
            }
        },
        legend: {
            data: series.map(s => s.name),
            type: 'scroll',
            orient: 'horizontal',
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Speed (MHz)'
        },
        series: series
    };
    chart.setOption(option);
    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

{{if .NVIDIAErrsChart}}
function createNVIDIAErrsChart(metrics) {
    const hwSlowdowns = metrics.filter(m => m.metric_name === 'accelerator_nvidia_clock_hw_slowdown');
    const hwSlowdownThermals = metrics.filter(m => m.metric_name === 'accelerator_nvidia_clock_hw_slowdown_thermal');
    const hwSlowdownPowerBrakes = metrics.filter(m => m.metric_name === 'accelerator_nvidia_clock_hw_slowdown_power_brake');

    const eccAggTotalCorrecteds = metrics.filter(m => m.metric_name === 'accelerator_nvidia_ecc_aggregate_total_corrected');
    const eccAggTotalUncorrecteds = metrics.filter(m => m.metric_name === 'accelerator_nvidia_ecc_aggregate_total_uncorrected');
    const eccVolTotalCorrecteds = metrics.filter(m => m.metric_name === 'accelerator_nvidia_ecc_volatile_total_corrected');
    const eccVolTotalUncorrecteds = metrics.filter(m => m.metric_name === 'accelerator_nvidia_ecc_volatile_total_uncorrected');

    // group by gpu_id
    const groupedMetrics = {};
    hwSlowdowns.forEach((entry, index) => {
        const gpuID = entry.extra_info.gpu_id;
        if (!groupedMetrics[gpuID]) {
            groupedMetrics[gpuID] = {
                hwSlowdowns: [],
                hwSlowdownThermals: [],
                hwSlowdownPowerBrakes: [],
                eccAggTotalCorrecteds: [],
                eccAggTotalUncorrecteds: [],
                eccVolTotalCorrecteds: [],
                eccVolTotalUncorrecteds: [],
            };
        }
        groupedMetrics[gpuID].hwSlowdowns.push(entry);
        groupedMetrics[gpuID].hwSlowdownThermals.push(hwSlowdownThermals[index]);
        groupedMetrics[gpuID].hwSlowdownPowerBrakes.push(hwSlowdownPowerBrakes[index]);
        groupedMetrics[gpuID].eccAggTotalCorrecteds.push(eccAggTotalCorrecteds[index]);
        groupedMetrics[gpuID].eccAggTotalUncorrecteds.push(eccAggTotalUncorrecteds[index]);
        groupedMetrics[gpuID].eccVolTotalCorrecteds.push(eccVolTotalCorrecteds[index]);
        groupedMetrics[gpuID].eccVolTotalUncorrecteds.push(eccVolTotalUncorrecteds[index]);
    });

    const series = Object.keys(groupedMetrics).map(gpuID => {
        const hwSlowdowns = groupedMetrics[gpuID].hwSlowdowns;
        const hwSlowdownThermals = groupedMetrics[gpuID].hwSlowdownThermals;
        const hwSlowdownPowerBrakes = groupedMetrics[gpuID].hwSlowdownPowerBrakes;
        const eccAggTotalCorrecteds = groupedMetrics[gpuID].eccAggTotalCorrecteds;
        const eccAggTotalUncorrecteds = groupedMetrics[gpuID].eccAggTotalUncorrecteds;
        const eccVolTotalCorrecteds = groupedMetrics[gpuID].eccVolTotalCorrecteds;
        const eccVolTotalUncorrecteds = groupedMetrics[gpuID].eccVolTotalUncorrecteds;

        const chartData = hwSlowdowns.map((hwSlowdownsEntry, index) => {
            return [
                hwSlowdownsEntry.unix_seconds * 1000,
                hwSlowdownsEntry.value,
                hwSlowdownThermals[index].value,
                hwSlowdownPowerBrakes[index].value,
                eccAggTotalCorrecteds[index].value,
                eccAggTotalUncorrecteds[index].value,
                eccVolTotalCorrecteds[index].value,
                eccVolTotalUncorrecteds[index].value
            ];
        });
        return [
            {
                name: `HW slowdown (${gpuID})`,
                type: 'line',
                stack: 'Total',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[1]])
            },
            {
                name: `HW slowdown thermal (${gpuID})`,
                type: 'line',
                stack: 'Total',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[2]])
            },
            {
                name: `HW slowdown power brake (${gpuID})`,
                type: 'line',
                stack: 'Total',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[3]])
            },
            {
                name: `ECC aggregate total corrected (${gpuID})`,
                type: 'line',
                stack: 'Total',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[4]])
            },
            {
                name: `ECC aggregate total uncorrected (${gpuID})`,
                type: 'line',
                stack: 'Total',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[5]])
            },
            {
                name: `ECC volatile total corrected (${gpuID})`,
                type: 'line',
                stack: 'Total',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[6]])
            },
            {
                name: `ECC volatile total uncorrected (${gpuID})`,
                type: 'line',
                stack: 'Total',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[7]])
            },
        ];
    }).flat();

    const chart = echarts.init(document.getElementById('nvidia-errs-chart'));
    const option = {
        title: {
            text: 'NVIDIA GPU error counts'
        },
        grid: {
            left: '10%',
            right: '5%',
            bottom: '15%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                let result = `<div style="font-weight: bold; margin-bottom: 3px; font-size: 10px;">${date.toLocaleString()}</div>`;

                const gpuData = {};
                params.forEach(param => {
                    const [type, gpuId] = param.seriesName.split(' (');
                    const gpu = gpuId.slice(0, -1); // Remove the closing parenthesis
                    if (!gpuData[gpu]) {
                        gpuData[gpu] = {};
                    }
                    gpuData[gpu][type] = `${param.value[1]}`;
                });

                const gpus = Object.keys(gpuData);
                for (let i = 0; i < gpus.length; i += 4) {
                    result += '<div style="display: flex; justify-content: flex-start; margin-top: 1px;">';
                    for (let j = i; j < Math.min(i + 4, gpus.length); j++) {
                        const gpu = gpus[j];
                        const data = gpuData[gpu];
                        result += `
                            <div style="flex: 0 0 23%; margin: 0 1px; padding: 1px; border: 1px solid #ccc; border-radius: 2px; font-size: 8px;">
                                <div style="font-weight: bold; margin-bottom: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${gpu.length > 7 ? gpu.substring(0, 7) + '..' : gpu}</div>
                                <div style="line-height: 1.2;">${Object.entries(data).map(([type, value]) => `${type}: ${value}`).join('<br>')}</div>
                            </div>
                        `;
                    }
                    result += '</div>';
                }

                return result;
            }
        },
        legend: {
            data: series.map(s => s.name),
            type: 'scroll',
            orient: 'horizontal',
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Errors'
        },
        series: series
    };
    chart.setOption(option);
    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

{{if .CPUChart}}
function createCPUChart(metrics) {
    const cpuUsedPercents = metrics.filter(m => m.metric_name === 'cpu_used_percent');
    const chartData = cpuUsedPercents.map(entry => {
        return [
            entry.unix_seconds * 1000,
            entry.value
        ];
    });

    const chart = echarts.init(document.getElementById('cpu-chart'));
    const option = {
        title: {
            text: 'CPU'
        },
        tooltip: {
            trigger: 'axis',
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                return `${date.toLocaleString()}<br>CPU: ${params[0].value[1].toFixed(2)}%`;
            }
        },
        legend: {
            data: ['CPU usage'],
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Used (%)',
            min: 0,
            max: 100
        },
        series: [{
            name: 'CPU usage',
            type: 'line',
            symbol: 'none',
            sampling: 'lttb',
            itemStyle: {
                color: 'rgb(65, 105, 225)' // Royal Blue
            },
            areaStyle: {
                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                    {
                        offset: 0,
                        color: 'rgb(173, 216, 230)' // Light Blue
                    },
                    {
                        offset: 1,
                        color: 'rgb(65, 105, 225)' // Royal Blue
                    }
                ])
            },
            data: chartData
        }]
    };
    chart.setOption(option);

    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

{{if .MemoryChart}}
function createMemoryChart(metrics) {
    const totalMemory = metrics.filter(m => m.metric_name === 'memory_total_bytes');
    const usedMemory = metrics.filter(m => m.metric_name === 'memory_used_bytes');

    const chartData = totalMemory.map((totalMemoryEntry, index) => {
        const used = usedMemory[index];
        return [
            totalMemoryEntry.unix_seconds * 1000,
            totalMemoryEntry.value / (1024 * 1024 * 1024), // Convert to GB
            used.value / (1024 * 1024 * 1024) // Convert to GB
        ];
    });

    const chart = echarts.init(document.getElementById('memory-chart'));
    const option = {
        title: {
            text: 'Memory'
        },
        grid: {
            left: '10%',
            right: '5%',
            bottom: '15%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                const total = params[0].value[1].toFixed(2);
                const used = params[1].value[1].toFixed(2);

                return `
                    <strong>${date.toLocaleString()}</strong><br>
                    Total: ${total} GB<br>
                    Used: ${used} GB
                `;
            }
        },
        legend: {
            data: ['Total', 'Used'],
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Memory (GB)'
        },
        series: [{
            name: 'Total',
            type: 'line',
            symbol: 'none',
            sampling: 'lttb',
            data: chartData.map(item => [item[0], item[1]])
        }, {
            name: 'Used',
            type: 'line',
            symbol: 'none',
            sampling: 'lttb',
            itemStyle: {
                color: 'rgb(255, 99, 71)' // Tomato red
            },
            areaStyle: {
                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                {
                    offset: 0,
                    color: 'rgb(255, 228, 225)' // Light red
                },
                {
                    offset: 1,
                    color: 'rgb(255, 99, 71)' // Tomato red
                }
                ])
            },
            data: chartData.map(item => [item[0], item[2]])
        }]
    };
    chart.setOption(option);
    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

{{if .FDChart}}
function createFDChart(metrics) {
    const usedPercents = metrics.filter(m => m.metric_name === 'fd_used_percent');

    const chartData = usedPercents.map(entry => {
        return [
            entry.unix_seconds * 1000,
            entry.value
        ];
    });

    const chart = echarts.init(document.getElementById('fd-chart'));
    const option = {
        title: {
            text: 'File descriptor'
        },
        grid: {
            left: '10%',
            right: '5%',
            bottom: '15%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                const used = params[0].value[1];
                return `
                    <strong>${date.toLocaleString()}</strong><br>
                    Used: ${used}
                `;
            }
        },
        legend: {
            data: ['File descriptor usage'],
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Used (%)',
            min: 0
        },
        series: [{
            name: 'File descriptor usage',
            type: 'line',
            symbol: 'none',
            sampling: 'lttb',
            itemStyle: {
                color: 'rgb(100, 200, 100)'
            },
            areaStyle: {
                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                {
                    offset: 0,
                    color: 'rgb(200, 250, 200)'
                },
                {
                    offset: 1,
                    color: 'rgb(100, 200, 100)'
                }
                ])
            },
            data: chartData.map(item => [item[0], item[1]])
        }]
    };
    chart.setOption(option);
    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

{{if .DiskChart}}
function createDiskChart(metrics) {
    const totalBytes = metrics.filter(m => m.metric_name === 'disk_total_bytes');
    const usedBytes = metrics.filter(m => m.metric_name === 'disk_used_bytes');

    // group by mount_point
    const groupedMetrics = {};
    totalBytes.forEach((entry, index) => {
        const mountPoint = entry.extra_info.mount_point;
        if (!groupedMetrics[mountPoint]) {
            groupedMetrics[mountPoint] = { total: [], used: [] };
        }
        groupedMetrics[mountPoint].total.push(entry);
        groupedMetrics[mountPoint].used.push(usedBytes[index]);
    });

    const series = Object.keys(groupedMetrics).map(mountPoint => {
        const total = groupedMetrics[mountPoint].total;
        const used = groupedMetrics[mountPoint].used;
        const chartData = total.map((totalEntry, index) => {
            return [
                totalEntry.unix_seconds * 1000,
                totalEntry.value / (1024 * 1024 * 1024), // Convert to GB
                used[index].value / (1024 * 1024 * 1024) // Convert to GB
            ];
        });
        return [
        {
                name: `Total (mount point ${mountPoint})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[1]])
            },
            {
                name: `Used (mount point ${mountPoint})`,
                type: 'line',
                symbol: 'none',
                sampling: 'lttb',
                data: chartData.map(item => [item[0], item[2]])
            }
        ];
    }).flat();

    const chart = echarts.init(document.getElementById('disk-chart'));
    const option = {
        title: {
            text: 'Disk'
        },
        grid: {
            left: '10%',
            right: '5%',
            bottom: '15%',
            containLabel: true
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'cross'
            },
            formatter: function (params) {
                const date = new Date(params[0].value[0]);
                let result = `<strong>${date.toLocaleString()}</strong><br>`;
                params.forEach(param => {
                    const value = param.value[1].toFixed(2);
                    // const mountPoint = param.seriesName.split(' ')[1].replace(/[()]/g, '');
                    result += `${param.seriesName}: ${value} GB<br>`;
                });
                return result;
            }
        },
        legend: {
            data: series.map(s => s.name),
            type: 'scroll',
            orient: 'horizontal',
            bottom: 0
        },
        xAxis: {
            type: 'time',
            axisLabel: {
                formatter: (value) => {
                    const date = new Date(value);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },
                interval: 'auto',
                rotate: 45
            },
            max: Date.now()
        },
        yAxis: {
            type: 'value',
            name: 'Disk (GB)'
        },
        series: series
    };
    chart.setOption(option);
    window.addEventListener('resize', () => {
        chart.resize();
    });
}
{{end}}

// initialize the charts and states when the page loads
document.addEventListener('DOMContentLoaded', () => {
    fetchAndDisplayStates();
    fetchAndDisplayEvents();
    renderChartsFromMetrics();
});
</script>

<div class="header">
    <h1><a href="https://github.com/leptonai/gpud" target="_blank">GPUd</a> dashboard</h1>
</div>

<div class="system-info">
    <div class="info-card platform">
        <h3>Platform Info</h3>
        <p><strong>Platform:</strong> {{.PlatformName}} (version {{.PlatformVersion}})</p>
        <p><strong>Uptime:</strong> {{.Uptime}} ({{.UptimeSeconds}}s)</p>
        <p><strong>Kernel:</strong> {{.KernelArch}} ({{.KernelVersion}}s)</p>
    </div>
    <div class="info-card accelerator">
        <h3>Accelerator Info</h3>
        <p><strong>Accelerator:</strong> {{.Accelerator}}</p>
        <p><strong>Driver:</strong> {{.AcceleratorDriver}}</p>
        <p><strong>GPU Attached:</strong> {{.GPUAttached}}</p>
    </div>
</div>

<div class="workloads-section">
    <h3 class="section-header" onclick="toggleStatesWorkloads()">
        Workloads <span id="systemStatesWorkloadsArrow">▼</span>
    </h3>
    <p id="workloads-summary" class="workloads-summary"></p>
    <div id="workloads-container" style="display: none;"></div>
</div>

<div class="states-section">
    <h3 class="section-header" onclick="toggleStatesNonWorkloads()">
        States <span id="systemStatesNonWorkloadsArrow">▼</span>
    </h3>
    <p id="states-summary" class="states-summary"></p>
    <div id="states-container" style="display: none;"></div>
</div>

<div class="events-section">
    <h3 class="section-header" onclick="toggleSystemEvents()">
        Events <span id="systemEventsArrow">▼</span>
    </h3>
    <p id="events-summary" class="events-summary"></p>
    <div id="events-container" style="display: none;"></div>
</div>







<div class="charts-row">
{{if .NVIDIAGPUUtilChart}}
    <div class="chart-container">
        <div id="nvidia-gpu-util-chart"></div>
    </div>
{{end}}
{{if .NVIDIAMemoryChart}}
    <div class="chart-container">
        <div id="nvidia-memory-chart"></div>
    </div>
{{end}}
</div>

<div class="charts-row">
{{if .NVIDIATemperatureChart}}
    <div class="chart-container">
        <div id="nvidia-temperature-chart"></div>
    </div>
{{end}}
{{if .NVIDIAPowerChart}}
    <div class="chart-container">
        <div id="nvidia-power-chart"></div>
    </div>
{{end}}
</div>

<div class="charts-row">
{{if .NVIDIAClockSpeedChart}}
    <div class="chart-container">
        <div id="nvidia-clock-speed-chart"></div>
    </div>
{{end}}
{{if .NVIDIAErrsChart}}
    <div class="chart-container">
        <div id="nvidia-errs-chart"></div>
    </div>
{{end}}
</div>





<div class="system-resources-section">
    <h3 class="section-header" onclick="toggleSystemResources()">
        Other system resources <span id="systemResourcesArrow">▼</span>
    </h3>
    <div id="systemResourcesCharts" style="display: none;">
        <div class="charts-row">
{{if .CPUChart}}
            <div class="chart-container">
                <div id="cpu-chart"></div>
            </div>
{{end}}
{{if .MemoryChart}}
            <div class="chart-container">
                <div id="memory-chart"></div>
            </div>
{{end}}
        </div>

        <div class="charts-row">
{{if .FDChart}}
            <div class="chart-container">
                <div id="fd-chart"></div>
            </div>
{{end}}
{{if .DiskChart}}
            <div class="chart-container">
                <div id="disk-chart"></div>
            </div>
{{end}}
        </div>
    </div>
</div>





{{if .Admin}}
<br>
<br>
<hr>
<div class="header">
    <h3>Admin panel</h3>
</div>
<form class="form-container">
    <div class="form-section">
        <p class="form-title">Select registered paths (for all components):</p>
        <div class="radio-group">
{{range .Paths}}
            <label class="radio-label" for="{{.Path}}">
                <input class="radio-input" type="radio" name="path" value="{{.Path}}" id="{{.Path}}" onchange="handleRadioChange(this)">
                <div class="path-info">
                    <code class="path-code">{{.Path}}</code>
                    <span class="path-description">{{.Desc}}</span>
                </div>
            </label>
{{end}}
        </div>
    </div>

    <div class="form-section">
        <p class="form-title">Select output format:</p>
        <div class="radio-group inline">
            <label class="radio-label">
                <input class="radio-input" type="radio" name="format" value="json" onchange="handleRadioChange(document.querySelector('input[name=path]:checked'))">
                <span>JSON</span>
            </label>
            <label class="radio-label">
                <input class="radio-input" type="radio" name="format" value="yaml" checked onchange="handleRadioChange(document.querySelector('input[name=path]:checked'))">
                <span>YAML</span>
            </label>
        </div>
    </div>
</form>

<div id="result-container">
    <h2 class="result-header">Output</h2>
    <div id="result"></div>
</div>

{{end}}

<!-- Move this to the bottom of the file, just before the closing </body> tag -->
<footer class="footer">
    <div class="footer-content">
        <div class="footer-section">
            <h3>GPUd info</h3>
            <p>gpud version: {{.Version}}</p>
            <p>gpud PID: {{.PID}}</p>
            <p>gpud RAM usage: alloc {{.MemoryAlloc}}, RSS {{.MemoryRSS}}</p>
        </div>
    </div>
</footer>
